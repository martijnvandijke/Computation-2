!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/darren@hiebert.com/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	4.0.3	//
ANCHOR	symbolic.c	28;"	d	file:
Aflag	main.c	/^int Aflag;		\/* >= 0 if -A specified *\/$/;"	v
Aflag	pass2.c	/^int Aflag;		\/* >= 0 if -A specified *\/$/;"	v
BEGIN	symbolic.c	24;"	d	file:
BLANK	lex.c	/^enum { BLANK=01,  NEWLINE=02, LETTER=04,$/;"	e	file:
DIGIT	lex.c	/^       DIGIT=010, HEX=020,    OTHER=040 };$/;"	e	file:
END	symbolic.c	25;"	d	file:
HASHSIZE	sym.c	17;"	d	file:
HEX	lex.c	/^       DIGIT=010, HEX=020,    OTHER=040 };$/;"	e	file:
I	bytecode.c	2;"	d	file:
I	null.c	2;"	d	file:
I	symbolic.c	5;"	d	file:
IR	main.c	/^Interface *IR = NULL;$/;"	v
IR	pass2.c	/^Interface *IR = NULL;$/;"	v
ITEM	symbolic.c	26;"	d	file:
LETTER	lex.c	/^enum { BLANK=01,  NEWLINE=02, LETTER=04,$/;"	e	file:
MAXTOKEN	lex.c	7;"	d	file:
MAXTOKEN	profio.c	23;"	d	file:
NEWLINE	lex.c	/^enum { BLANK=01,  NEWLINE=02, LETTER=04,$/;"	e	file:
NEWLINE	symbolic.c	29;"	d	file:
NeedsReg	gen.c	/^static char NeedsReg[] = {$/;"	v	file:
OTHER	lex.c	/^       DIGIT=010, HEX=020,    OTHER=040 };$/;"	e	file:
Pflag	main.c	/^int Pflag;		\/* != 0 if -P specified *\/$/;"	v
Pflag	pass2.c	/^int Pflag;		\/* != 0 if -P specified *\/$/;"	v
START	symbolic.c	27;"	d	file:
SWSIZE	stmt.c	5;"	d	file:
T	pass2.c	398;"	d	file:
T	pass2.c	490;"	d	file:
VERBOSE	pass2.c	19;"	d	file:
YYcheck	main.c	/^Symbol YYcheck;		\/* _YYcheck symbol if -nvalidate,check specified *\/$/;"	v
YYcheck	pass2.c	/^Symbol YYcheck;		\/* _YYcheck symbol if -nvalidate,check specified *\/$/;"	v
YYcounts	prof.c	/^static Symbol YYcounts;	\/* symbol for _YYcounts if -b specified *\/$/;"	v	file:
YYlink	prof.c	/^static Symbol YYlink;	\/* symbol for file's struct _bbdata *\/$/;"	v	file:
YYnull	main.c	/^Symbol YYnull;		\/* _YYnull  symbol if -n or -nvalidate specified *\/$/;"	v
YYnull	pass2.c	/^Symbol YYnull;		\/* _YYnull  symbol if -n or -nvalidate specified *\/$/;"	v
a	alloc.c	/^	union align a;$/;"	m	union:header
acaller	profio.c	/^static void acaller(char *caller, char *file, int x, int y, int count, struct func *callee) {$/;"	f	file:
add	decl.c	5;"	d	file:
addd	simp.c	/^static int addd(double x, double y, double min, double max, int needconst) {$/;"	f	file:
addi	simp.c	/^static int addi(long x, long y, long min, long max, int needconst) {$/;"	f	file:
addlocal	stmt.c	/^void addlocal(Symbol p) {$/;"	f
address	bytecode.c	/^static void I(address)(Symbol q, Symbol p, long n) {$/;"	f	file:
address	null.c	/^static void I(address)(Symbol q, Symbol p, long n) {}$/;"	f	file:
address	symbolic.c	/^static void I(address)(Symbol q, Symbol p, long n) {$/;"	f	file:
addrof	enode.c	/^Tree addrof(Tree p) {$/;"	f
addrtree	simp.c	/^static Tree addrtree(Tree e, long n, Type ty) {$/;"	f	file:
addtree	enode.c	/^static Tree addtree(int op, Tree l, Tree r) {$/;"	f	file:
afunc	prof.c	/^static Symbol afunc;	\/* current function's struct func *\/$/;"	v	file:
afunction	profio.c	/^static struct func *afunction(char *name, char *file, int x, int y, int count) {$/;"	f	file:
align	alloc.c	/^union align {$/;"	u	file:
all	sym.c	/^	Symbol all;$/;"	m	struct:table
allocate	alloc.c	/^void *allocate(unsigned long n, unsigned a) {$/;"	f
allsymbols	sym.c	/^Symbol allsymbols(Table tp) {$/;"	f
andtree	enode.c	/^static Tree andtree(int op, Tree l, Tree r) {$/;"	f	file:
apoint	profio.c	/^static void apoint(int i, char *file, int x, int y, int count) {$/;"	f	file:
append	list.c	/^List append(void *x, List list) {$/;"	f
appendstr	trace.c	/^static void appendstr(char *str) {$/;"	f	file:
apply	event.c	/^void apply(List event, void *arg1, void *arg2) {$/;"	f
arena	alloc.c	/^	*arena[] = { &first[0], &first[1], &first[2] };$/;"	v	file:
arena	alloc.c	/^union header *arena[3];$/;"	v
argoffset	gen.c	/^int argoffset;$/;"	v
args	trace.c	/^static Tree args;		\/* printf arguments *\/$/;"	v	file:
array	types.c	/^Type array(Type ty, int n, int a) {$/;"	f
asdl_address	asdl.c	/^static void asdl_address(Symbol q, Symbol p, long n) {$/;"	f	file:
asdl_blockbeg	asdl.c	/^static void asdl_blockbeg(Env *e) {$/;"	f	file:
asdl_blockend	asdl.c	/^static void asdl_blockend(Env *e) {$/;"	f	file:
asdl_defaddress	asdl.c	/^static void asdl_defaddress(Symbol p) {$/;"	f	file:
asdl_defconst	asdl.c	/^static void asdl_defconst(int suffix, int size, Value v) {$/;"	f	file:
asdl_defstring	asdl.c	/^static void asdl_defstring(int len, char *str) {$/;"	f	file:
asdl_defsymbol	asdl.c	/^static void asdl_defsymbol(Symbol p) {$/;"	f	file:
asdl_emit	asdl.c	/^static void asdl_emit(Node p) {}$/;"	f	file:
asdl_export	asdl.c	/^static void asdl_export(Symbol p) {$/;"	f	file:
asdl_function	asdl.c	/^static void asdl_function(Symbol f, Symbol caller[], Symbol callee[], int ncalls) {$/;"	f	file:
asdl_gen	asdl.c	/^static Node asdl_gen(Node p) {$/;"	f	file:
asdl_global	asdl.c	/^static void asdl_global(Symbol p) {$/;"	f	file:
asdl_import	asdl.c	/^static void asdl_import(Symbol p) {$/;"	f	file:
asdl_init	asdl.c	/^void asdl_init(int argc, char *argv[]) {$/;"	f
asdl_local	asdl.c	/^static void asdl_local(Symbol p) {$/;"	f	file:
asdl_progbeg	asdl.c	/^static void asdl_progbeg(int argc, char *argv[]) {$/;"	f	file:
asdl_progend	asdl.c	/^static void asdl_progend(void) {$/;"	f	file:
asdl_segment	asdl.c	/^static void asdl_segment(int n) {$/;"	f	file:
asdl_space	asdl.c	/^static void asdl_space(int n) {$/;"	f	file:
asgn	enode.c	/^Tree asgn(Symbol p, Tree e) {$/;"	f
asgncode	stab.c	/^static void asgncode(Type ty, int lev) {$/;"	f	file:
asgnnode	dag.c	/^static Node asgnnode(Symbol tmp, Node p) {$/;"	f	file:
asgntree	enode.c	/^Tree asgntree(int op, Tree l, Tree r) {$/;"	f
askfixedreg	gen.c	/^static Symbol askfixedreg(Symbol s) {$/;"	f	file:
askreg	gen.c	/^static Symbol askreg(Symbol rs, unsigned rmask[]) {$/;"	f	file:
askregvar	gen.c	/^int askregvar(Symbol p, Symbol regs) {$/;"	f
assign	enode.c	/^Type assign(Type xty, Tree e) {$/;"	f
assignargs	dag.c	/^int assignargs = 1;$/;"	v
atop	types.c	/^Type atop(Type ty) {$/;"	f
attach	event.c	/^void attach(Apply func, void *cl, List *list) {$/;"	f
attributes	2html.c	247;"	d	file:
attributes	2html.c	284;"	d	file:
attributes	2html.c	290;"	d	file:
attributes	2html.c	302;"	d	file:
attributes	2html.c	342;"	d	file:
attributes	2html.c	413;"	d	file:
attributes	2html.c	434;"	d	file:
attributes	2html.c	495;"	d	file:
autos	decl.c	/^static List autos, registers;$/;"	v	file:
avail	alloc.c	/^	char *avail;$/;"	m	struct:block
b	alloc.c	/^	struct block b;$/;"	m	union:header
b_blockbeg	bytecode.c	235;"	d	file:
b_blockend	bytecode.c	236;"	d	file:
backslash	lex.c	/^static int backslash(int q) {$/;"	f	file:
bbcall	prof.c	/^static void bbcall(Symbol yycounts, Coordinate *cp, Tree *e) {$/;"	f	file:
bbentry	prof.c	/^static void bbentry(Symbol yylink, Symbol f) {$/;"	f	file:
bbexit	prof.c	/^static void bbexit(Symbol yylink, Symbol f, Tree e) {$/;"	f	file:
bbfile	prof.c	/^static int bbfile(char *file) {$/;"	f	file:
bbfunc	prof.c	/^static void bbfunc(Symbol yylink, Symbol f) {$/;"	f	file:
bbincr	prof.c	/^static void bbincr(Symbol yycounts, Coordinate *cp, Tree *e) {$/;"	f	file:
bbvars	prof.c	/^static void bbvars(Symbol yylink) {$/;"	f	file:
be	prof.c	/^		struct { unsigned int index:6,x:10,y:16; } be;$/;"	m	union:callsite::coordinate
begin	pass2.c	/^	Code begin;$/;"	m	struct:block
bflag	gen.c	/^int bflag = 0;  \/* omit *\/$/;"	v
binary	expr.c	/^Type binary(Type xty, Type yty) {$/;"	f
bindings	bind.c	/^Binding bindings[] = {$/;"	v
bits2bytes	decl.c	7;"	d	file:
bittree	enode.c	/^Tree bittree(int op, Tree l, Tree r) {$/;"	f
blkcopy	gen.c	/^void blkcopy(int dreg, int doff, int sreg, int soff, int size, int tmp[]) {$/;"	f
blkunroll	gen.c	/^static void blkunroll(int k, int dreg, int doff, int sreg, int soff, int size, int tmp[]) {$/;"	f	file:
block	alloc.c	/^struct block {$/;"	s	file:
block	pass2.c	/^static struct block {$/;"	s	file:
blockbeg	gen.c	/^void blockbeg(Env *e) {$/;"	f
blockbeg	null.c	/^static void I(blockbeg)(Env *e) {}$/;"	f	file:
blockbeg	symbolic.c	/^static void I(blockbeg)(Env *e) {$/;"	f	file:
blockend	gen.c	/^void blockend(Env *e) {$/;"	f
blockend	null.c	/^static void I(blockend)(Env *e) {}$/;"	f	file:
blockend	symbolic.c	/^static void I(blockend)(Env *e) {$/;"	f	file:
blockstack	pass2.c	/^} *blockstack = NULL;$/;"	v	file:
branch	stmt.c	/^void branch(int lab) {$/;"	f
bsize	input.c	/^static int bsize;$/;"	v	file:
btot	types.c	/^Type btot(int op, int size) {$/;"	f
buckets	dag.c	/^} *buckets[16];$/;"	v	file:
buckets	string.c	/^} *buckets[1024];$/;"	v	file:
buckets	sym.c	/^	} *buckets[256];$/;"	m	struct:table
buffer	input.c	/^static unsigned char buffer[MAXLINE+1 + BUFSIZE+1];$/;"	v	file:
bytecodeIR	bytecode.c	/^Interface bytecodeIR = {$/;"	v
call	enode.c	/^Tree call(Tree f, Type fty, Coordinate src) {$/;"	f
caller	profio.c	/^		struct caller {		\/* caller data: *\/$/;"	s	file:	struct:file::func
callers	prof.c	/^	struct caller *callers;$/;"	m	struct:func
callers	profio.c	/^		} *callers;$/;"	m	struct:file::func
callsite	prof.c	/^struct callsite {$/;"	s	file:
calltree	enode.c	/^Tree calltree(Tree f, Type ty, Tree args, Symbol t3) {$/;"	f
caselabel	2html.c	241;"	d	file:
caselabel	stmt.c	/^static void caselabel(Swtch swp, long val, int lab) {$/;"	f	file:
cast	expr.c	/^Tree cast(Tree p, Type type) {$/;"	f
cbuf	lex.c	/^static char cbuf[BUFSIZE+1];$/;"	v	file:
cfoldcnst	simp.c	34;"	d	file:
cfunc	decl.c	/^Symbol cfunc;		\/* current function *\/$/;"	v
charptype	types.c	/^Type charptype;			\/* char* *\/$/;"	v
chartype	types.c	/^Type chartype;			\/* char *\/$/;"	v
checklab	decl.c	/^void checklab(Symbol p, void *cl) {$/;"	f
checkref	decl.c	/^static void checkref(Symbol p, void *cl) {$/;"	f	file:
checkuid	asdl.c	/^static int checkuid(list_ty list) {$/;"	f	file:
chkoverflow	decl.c	6;"	d	file:
ck	gen.c	252;"	d	file:
cl	event.c	/^	void *cl;$/;"	m	struct:entry
cmp	stmt.c	/^static void cmp(int op, Symbol p, long n, int lab) {$/;"	f	file:
cmptree	enode.c	/^static Tree cmptree(int op, Tree l, Tree r) {$/;"	f	file:
cns	sym.c	/^	cns = { CONSTANTS },$/;"	v	file:
cnsttree	enode.c	/^Tree cnsttree(Type ty, ...) {$/;"	f
code	stmt.c	/^Code code(int kind) {$/;"	f
codehead	stmt.c	/^struct code codehead = { Start };$/;"	v
codelist	stmt.c	/^Code codelist = &codehead;$/;"	v
comment	main.c	/^static char *comment;$/;"	v	file:
commute	simp.c	9;"	d	file:
compare	profio.c	/^static int compare(struct count *a, struct count *b) {$/;"	f	file:
compatible	enode.c	/^static int compatible(Type ty1, Type ty2) {$/;"	f	file:
compose	types.c	/^Type compose(Type ty1, Type ty2) {$/;"	f
compound	decl.c	/^void compound(int loop, struct swtch *swp, int lev) {$/;"	f
cond	expr.c	/^Tree cond(Tree p) {$/;"	f
conditional	stmt.c	/^static Tree conditional(int tok) {$/;"	f	file:
condtree	enode.c	/^Tree condtree(Tree e, Tree l, Tree r) {$/;"	f
constant	sym.c	/^Symbol constant(Type ty, Value v) {$/;"	f
constants	sym.c	/^Table constants   = &cns;$/;"	v
constexpr	simp.c	/^Tree constexpr(int tok) {$/;"	f
consttree	enode.c	/^Tree consttree(unsigned n, Type ty) {$/;"	f
coord	prof.c	/^		unsigned int coord;$/;"	m	union:callsite::coordinate
coordinate	prof.c	/^	union coordinate {$/;"	u	file:	struct:callsite
count	profio.c	/^			int count;		\/* number of calls from this site *\/$/;"	m	struct:file::func::caller
count	profio.c	/^		struct count count;		\/* total number of calls *\/$/;"	m	struct:file::func
count	profio.c	/^	int count;			\/* associated execution count *\/$/;"	m	struct:count
count	profio.c	/^	int count;			\/* counts[0..count-1] hold valid data *\/$/;"	m	struct:file
count	profio.c	/^struct count {			\/* count data: *\/$/;"	s	file:
counts	profio.c	/^	struct count *counts;		\/* count data *\/$/;"	m	struct:file
cp	input.c	/^unsigned char *cp;	\/* current input character *\/$/;"	v
cput	lex.c	/^static void *cput(int c, void *cl) {$/;"	f	file:
currentfile	main.c	/^static char *currentfile;       \/* current file name *\/$/;"	v	file:
currentfile	stab.c	/^static char *currentfile;       \/* current file name *\/$/;"	v	file:
currentline	main.c	/^static int currentline;		\/* current line number *\/$/;"	v	file:
curseg	init.c	/^static int curseg;		\/* current segment *\/$/;"	v	file:
cvtconst	dag.c	/^Tree cvtconst(Tree p) {$/;"	f
d	alloc.c	/^	double d;$/;"	m	union:align
dag	dag.c	/^static struct dag {$/;"	s	file:
dagnode	dag.c	/^static struct dag *dagnode(int op, Node l, Node r, Symbol sym) {$/;"	f	file:
dalign	gen.c	/^int dalign, salign;$/;"	v
dbxout	stab.c	/^static void dbxout(Type ty) {$/;"	f	file:
dbxtype	stab.c	/^static int dbxtype(Type ty) {$/;"	f	file:
dclglobal	decl.c	/^static Symbol dclglobal(int sclass, char *id, Type ty, Coordinate *pos) {$/;"	f	file:
dcllocal	decl.c	/^static Symbol dcllocal(int sclass, char *id, Type ty, Coordinate *pos) {$/;"	f	file:
dclparam	decl.c	/^static Symbol dclparam(int sclass, char *id, Type ty, Coordinate *pos) {$/;"	f	file:
dclr	decl.c	/^static Type dclr(Type basety, char **id, Symbol **params, int abstract) {$/;"	f	file:
dclr1	decl.c	/^static Type dclr1(char **id, Symbol **params, int abstract) {$/;"	f	file:
deallocate	alloc.c	/^void deallocate(unsigned a) {$/;"	f
decl	decl.c	/^static void decl(Symbol (*dcl)(int, char *, Type, Coordinate *)) {$/;"	f	file:
defaddress	bytecode.c	/^static void I(defaddress)(Symbol p) {$/;"	f	file:
defaddress	null.c	/^static void I(defaddress)(Symbol p) {}$/;"	f	file:
defaddress	symbolic.c	/^static void I(defaddress)(Symbol p){$/;"	f	file:
defconst	bytecode.c	/^static void I(defconst)(int suffix, int size, Value v) {$/;"	f	file:
defconst	null.c	/^static void I(defconst)(int suffix, int size, Value v) {}$/;"	f	file:
defconst	symbolic.c	/^static void I(defconst)(int suffix, int size, Value v) {$/;"	f	file:
defglobal	decl.c	/^void defglobal(Symbol p, int seg) {$/;"	f
definelab	stmt.c	/^void definelab(int lab) {$/;"	f
definept	stmt.c	/^void definept(Coordinate *p) {$/;"	f
defpointer	init.c	/^void defpointer(Symbol p) {$/;"	f
defstring	bytecode.c	/^static void I(defstring)(int len, char *str) {$/;"	f	file:
defstring	null.c	/^static void I(defstring)(int len, char *s) {}$/;"	f	file:
defstring	symbolic.c	/^static void I(defstring)(int len, char *s) {$/;"	f	file:
defsymbol	bytecode.c	/^static void I(defsymbol)(Symbol p) {$/;"	f	file:
defsymbol	null.c	/^static void I(defsymbol)(Symbol p) {}$/;"	f	file:
defsymbol	symbolic.c	/^static void I(defsymbol)(Symbol p) {$/;"	f	file:
den	stmt.c	7;"	d	file:
density	stmt.c	/^float density = 0.5;$/;"	v
depth	dag.c	/^static int depth = 0;$/;"	v	file:
deref	types.c	/^Type deref(Type ty) {$/;"	f
dflag	gen.c	/^int dflag = 0;$/;"	v
divd	simp.c	/^static int divd(double x, double y, double min, double max, int needconst) {$/;"	f	file:
divi	simp.c	/^static int divi(long x, long y, long min, long max, int needconst) {$/;"	f	file:
doAddress	pass2.c	/^static void doAddress(rcc_interface_ty in) {$/;"	f	file:
doBlockbeg	pass2.c	/^static void doBlockbeg(rcc_interface_ty in) {$/;"	f	file:
doBlockend	pass2.c	/^static void doBlockend(rcc_interface_ty in) {$/;"	f	file:
doDefaddress	pass2.c	/^static void doDefaddress(rcc_interface_ty in) {$/;"	f	file:
doDefconst	pass2.c	/^static void doDefconst(rcc_interface_ty in) {$/;"	f	file:
doDefconstf	pass2.c	/^static void doDefconstf(rcc_interface_ty in) {$/;"	f	file:
doDeflabel	pass2.c	/^static void doDeflabel(rcc_interface_ty in) {$/;"	f	file:
doDefstring	pass2.c	/^static void doDefstring(rcc_interface_ty in) {$/;"	f	file:
doExport	pass2.c	/^static void doExport(rcc_interface_ty in) {$/;"	f	file:
doForest	pass2.c	/^static void doForest(rcc_interface_ty in) {$/;"	f	file:
doFunction	pass2.c	/^static void doFunction(rcc_interface_ty in) {$/;"	f	file:
doGlobal	pass2.c	/^static void doGlobal(rcc_interface_ty in) {$/;"	f	file:
doImport	pass2.c	/^static void doImport(rcc_interface_ty in) {$/;"	f	file:
doLocal	pass2.c	/^static void doLocal(rcc_interface_ty in) {$/;"	f	file:
doSegment	pass2.c	/^static void doSegment(rcc_interface_ty in) {$/;"	f	file:
doSpace	pass2.c	/^static void doSpace(rcc_interface_ty in) {$/;"	f	file:
doX	pass2.c	/^static void (*doX[])(rcc_interface_ty in) = {$/;"	v	file:
do_define_label	2html.c	/^static void do_define_label(int x) {$/;"	f	file:
do_define_uid	2html.c	/^static void do_define_uid(int x) {$/;"	f	file:
do_enum	2html.c	/^static void do_enum(void *x) {$/;"	f	file:
do_enum_list	2html.c	/^static void do_enum_list(list_ty x) {$/;"	f	file:
do_field	2html.c	/^static void do_field(void *x) {$/;"	f	file:
do_field_list	2html.c	/^static void do_field_list(list_ty x) {$/;"	f	file:
do_flags	2html.c	/^static void do_flags(int x) {$/;"	f	file:
do_generic_string	2html.c	/^static void do_generic_string(void *x) {$/;"	f	file:
do_identifier	2html.c	/^static void do_identifier(const char *x) {$/;"	f	file:
do_int	2html.c	/^static void do_int(int x) {$/;"	f	file:
do_interface	2html.c	/^static void do_interface(void *y) {$/;"	f	file:
do_interface_list	2html.c	/^static void do_interface_list(list_ty x) {$/;"	f	file:
do_item	2html.c	/^static void do_item(rcc_item_ty x) {$/;"	f	file:
do_item_list	2html.c	/^static void do_item_list(list_ty x) {$/;"	f	file:
do_label	2html.c	/^static void do_label(int x) {$/;"	f	file:
do_list	2html.c	/^static void do_list(list_ty x, void do_one(void *), char *type, char *listhtml, char *separator) {$/;"	f	file:
do_node	2html.c	/^static void do_node(void *y) {$/;"	f	file:
do_node_list	2html.c	/^static void do_node_list(list_ty x) {$/;"	f	file:
do_op	2html.c	/^static void do_op(int x) {$/;"	f	file:
do_program	2html.c	/^static void do_program(rcc_program_ty x) {$/;"	f	file:
do_real	2html.c	/^static void do_real(rcc_real_ty x) {$/;"	f	file:
do_sclass	2html.c	/^static void do_sclass(int x) {$/;"	f	file:
do_scope	2html.c	/^static void do_scope(int x) {$/;"	f	file:
do_seg	2html.c	/^static void do_seg(int x) {$/;"	f	file:
do_string	2html.c	/^static void do_string(string_ty x) {$/;"	f	file:
do_string_list	2html.c	/^static void do_string_list(list_ty x) {$/;"	f	file:
do_suffix	2html.c	/^static void do_suffix(int x) {$/;"	f	file:
do_symbol	2html.c	/^static void do_symbol(rcc_symbol_ty x) {$/;"	f	file:
do_type	2html.c	/^static void do_type(rcc_type_ty x) {$/;"	f	file:
do_uid	2html.c	/^static void do_uid(int x) {$/;"	f	file:
do_uid_list	2html.c	/^static void do_uid_list(list_ty x) {$/;"	f	file:
docall	gen.c	/^static void docall(Node p) {$/;"	f	file:
doconst	decl.c	/^void doconst(Symbol p, void *cl) {$/;"	f
doextern	decl.c	/^static void doextern(Symbol p, void *cl) {$/;"	f	file:
doglobal	decl.c	/^static void doglobal(Symbol p, void *cl) {$/;"	f	file:
dopending	asdl.c	/^static void dopending(Symbol p) {$/;"	f	file:
dostmt	stmt.c	/^static void dostmt(int lab, Swtch swp, int lev) {$/;"	f	file:
doubletype	types.c	/^Type doubletype;		\/* double *\/$/;"	v
dumpcover	gen.c	/^static void dumpcover(Node p, int nt, int in) {$/;"	f	file:
dumpregs	gen.c	/^static void dumpregs(char *msg, char *a, char *b) {$/;"	f	file:
dumprule	gen.c	/^static void dumprule(int rulenum) {$/;"	f	file:
dumptree	bytecode.c	/^static void dumptree(Node p) {$/;"	f	file:
dumptree	gen.c	/^static void dumptree(Node p) {$/;"	f	file:
emit	bytecode.c	/^static void I(emit)(Node p) {$/;"	f	file:
emit	gen.c	/^void emit(Node p) {$/;"	f
emit	null.c	/^static void I(emit)(Node p) {}$/;"	f	file:
emit	symbolic.c	/^static void I(emit)(Node p){$/;"	f	file:
emitCoord	symbolic.c	/^static void emitCoord(Coordinate src) {$/;"	f	file:
emitString	symbolic.c	/^static void emitString(int len, const char *s) {$/;"	f	file:
emitSymRef	symbolic.c	/^static void emitSymRef(Symbol p) {$/;"	f	file:
emitSymbol	symbolic.c	/^static void emitSymbol(Symbol p) {$/;"	f	file:
emitasm	gen.c	/^static unsigned emitasm(Node p, int nt) {$/;"	f	file:
emitcode	dag.c	/^void emitcode(void) {$/;"	f
emitter	gen.c	/^unsigned (*emitter)(Node, int) = emitasm;$/;"	v
emittype	stab.c	/^static int emittype(Type ty, int lev, int col) {$/;"	f	file:
enterscope	sym.c	/^void enterscope(void) {$/;"	f
entry	event.c	/^struct entry {$/;"	s	file:
entry	sym.c	/^	struct entry {$/;"	s	file:	struct:table
entry	types.c	/^static struct entry {$/;"	s	file:
enumdcl	decl.c	/^Type enumdcl(void) {$/;"	f
eqtree	enode.c	/^Tree eqtree(int op, Tree l, Tree r) {$/;"	f
eqtype	types.c	/^int eqtype(Type ty1, Type ty2, int ret) {$/;"	f
equal	stmt.c	/^static int equal(Symbol lprime, Symbol dst) {$/;"	f	file:
equalp	sym.c	6;"	d	file:
equated	dag.c	/^static Symbol equated(Symbol p) {$/;"	f	file:
equatelab	stmt.c	/^void equatelab(Symbol old, Symbol new) {$/;"	f
errcnt	error.c	/^int errcnt   = 0;$/;"	v
errlimit	error.c	/^int errlimit = 20;$/;"	v
error	error.c	/^void error(const char *fmt, ...) {$/;"	f
events	event.c	/^Events events;$/;"	v
exitparams	decl.c	/^static void exitparams(Symbol params[]) {$/;"	f	file:
exitscope	sym.c	/^void exitscope(void) {$/;"	f
expect	error.c	/^void expect(int tok) {$/;"	f
explicitCast	simp.c	/^int explicitCast;$/;"	v
export	bytecode.c	/^static void I(export)(Symbol p) {$/;"	f	file:
export	null.c	/^static void I(export)(Symbol p) {}$/;"	f	file:
export	symbolic.c	/^static void I(export)(Symbol p) {$/;"	f	file:
expr	expr.c	/^Tree expr(int tok) {$/;"	f
expr0	expr.c	/^Tree expr0(int tok) {$/;"	f
expr1	expr.c	/^Tree expr1(int tok) {$/;"	f
expr2	expr.c	/^static Tree expr2(void) {$/;"	f	file:
expr3	expr.c	/^static Tree expr3(int k) {$/;"	f	file:
ext	sym.c	/^	ext = { GLOBAL },$/;"	v	file:
externals	sym.c	/^Table externals   = &ext;$/;"	v
f	alloc.c	/^	int (*f)(void);$/;"	m	union:align
fatal	error.c	/^int fatal(const char *name, const char *fmt, int n) {$/;"	f
fcon	lex.c	/^static Symbol fcon(void) {$/;"	f	file:
field	expr.c	/^Tree field(Tree p, const char *name) {$/;"	f
fieldlist	types.c	/^Field fieldlist(Type ty) {$/;"	f
fieldref	types.c	/^Field fieldref(const char *name, Type ty) {$/;"	f
fields	decl.c	/^static void fields(Type ty) {$/;"	f	file:
file	input.c	/^char *file;		\/* current input file name *\/$/;"	v
file	prof.c	/^	char *file, *name;$/;"	m	struct:callsite
file	profio.c	/^			char *file;		\/* call site: file, x, y *\/$/;"	m	struct:file::func::caller
file	profio.c	/^struct file {			\/* per-file prof.out data: *\/$/;"	s	file:
filelist	prof.c	/^static List filelist;	\/* list of file names *\/$/;"	v	file:
filelist	profio.c	/^} *filelist;$/;"	v
fillbuf	input.c	/^void fillbuf(void) {$/;"	f
finalize	decl.c	/^void finalize(void) {$/;"	f
findcount	profio.c	/^int findcount(char *file, int x, int y) {$/;"	f
findfile	profio.c	/^static struct file *findfile(char *name) {$/;"	f	file:
findfunc	profio.c	/^int findfunc(char *name, char *file) {$/;"	f
findlabel	sym.c	/^Symbol findlabel(int lab) {$/;"	f
findtype	sym.c	/^Symbol findtype(Type ty) {$/;"	f
first	alloc.c	/^	 first[] = {  { NULL },  { NULL },  { NULL } },$/;"	v	file:
firstarg	dag.c	/^static Tree firstarg;$/;"	v	file:
firstfile	input.c	/^char *firstfile;	\/* first input file *\/$/;"	v
fixup	dag.c	/^static void fixup(Node p) {$/;"	f	file:
floattype	types.c	/^Type floattype;			\/* float *\/$/;"	v
fmt	trace.c	/^static char *fmt, *fp, *fmtend;	\/* format string, current & limit pointer *\/$/;"	v	file:
fmtend	trace.c	/^static char *fmt, *fp, *fmtend;	\/* format string, current & limit pointer *\/$/;"	v	file:
foldaddp	simp.c	37;"	d	file:
foldcnst	simp.c	6;"	d	file:
foldcond	stmt.c	/^static int foldcond(Tree e1, Tree e2) {$/;"	f	file:
foreach	sym.c	/^void foreach(Table tp, int lev, void (*apply)(Symbol, void *), void *cl) {$/;"	f
forest	dag.c	/^static Node forest;$/;"	v	file:
forstmt	stmt.c	/^static void forstmt(int lab, Swtch swp, int lev) {$/;"	f	file:
fp	profio.c	/^FILE *fp;$/;"	v
fp	trace.c	/^static char *fmt, *fp, *fmtend;	\/* format string, current & limit pointer *\/$/;"	v	file:
fprint	output.c	/^void fprint(FILE *f, const char *fmt, ...) {$/;"	f
frameno	trace.c	/^static Symbol frameno;		\/* local holding frame number *\/$/;"	v	file:
framesize	gen.c	/^int framesize;$/;"	v
freeblocks	alloc.c	/^static struct block *freeblocks;$/;"	v	file:
freemask	gen.c	/^unsigned freemask[2];$/;"	v
freenodes	list.c	/^static List freenodes;		\/* free list nodes *\/$/;"	v	file:
freturn	types.c	/^Type freturn(Type ty) {$/;"	f
ftype	types.c	/^Type ftype(Type rty, Type ty) {$/;"	f
func	event.c	/^	Apply func;$/;"	m	struct:entry
func	prof.c	/^struct func {$/;"	s	file:
func	profio.c	/^	struct func {			\/* function data: *\/$/;"	s	file:	struct:file
func	types.c	/^Type func(Type ty, Type *proto, int style) {$/;"	f
funcdefn	decl.c	/^static void funcdefn(int sclass, char *id, Type ty, Symbol params[], Coordinate pt) {$/;"	f	file:
funclist	prof.c	/^static Symbol funclist;	\/* list of struct func *'s *\/$/;"	v	file:
funcname	expr.c	/^char *funcname(Tree f) {$/;"	f
funcptype	types.c	/^Type funcptype;			\/* void (*)() *\/$/;"	v
funcs	profio.c	/^	} *funcs;			\/* list of functions *\/$/;"	m	struct:file
function	bytecode.c	/^static void I(function)(Symbol f, Symbol caller[], Symbol callee[], int ncalls) {$/;"	f	file:
function	null.c	/^static void I(function)(Symbol f, Symbol caller[], Symbol callee[], int ncalls) {}$/;"	f	file:
function	symbolic.c	/^static void I(function)(Symbol f, Symbol caller[], Symbol callee[], int ncalls) {$/;"	f	file:
gather	profio.c	/^static int gather(void) {$/;"	f	file:
gen	bytecode.c	/^static Node I(gen)(Node p) {$/;"	f	file:
gen	gen.c	/^Node gen(Node forest) {$/;"	f
gen	null.c	/^static Node I(gen)(Node p) { return p; }$/;"	f	file:
gen	symbolic.c	/^static Node I(gen)(Node p) {$/;"	f	file:
gen01	bytecode.c	/^static void gen01(Node p) {$/;"	f	file:
gen02	bytecode.c	/^static void gen02(Node p) {$/;"	f	file:
gencode	dag.c	/^void gencode(Symbol caller[], Symbol callee[]) {$/;"	f
genconst	init.c	/^static int genconst(Tree e, int def) {$/;"	f	file:
genident	sym.c	/^Symbol genident(int scls, Type ty, int lev) {$/;"	f
genlabel	sym.c	/^int genlabel(int n) {$/;"	f
genreload	gen.c	/^static void genreload(Node p, Symbol tmp, int i) {$/;"	f	file:
genspill	gen.c	/^static void genspill(Symbol r, Node last, Symbol tmp) {$/;"	f	file:
getchr	lex.c	/^int getchr(void) {$/;"	f
getd	profio.c	/^static int getd(void) {$/;"	f	file:
getreg	gen.c	/^static Symbol getreg(Symbol s, unsigned mask[], Node p) {$/;"	f	file:
getregnum	gen.c	/^int getregnum(Node p) {$/;"	f
getrule	gen.c	/^static int getrule(Node p, int nt) {$/;"	f	file:
getstr	profio.c	/^static char *getstr(void) {$/;"	f	file:
gettok	lex.c	/^int gettok(void) {$/;"	f
geu	simp.c	47;"	d	file:
glevel	main.c	/^int glevel;		\/* == [0-9] if -g[0-9] specified *\/$/;"	v
glevel	pass2.c	/^int glevel;		\/* == [0-9] if -g[0-9] specified *\/$/;"	v
global	bytecode.c	/^static void I(global)(Symbol p) {$/;"	f	file:
global	null.c	/^static void I(global)(Symbol p) {}$/;"	f	file:
global	symbolic.c	/^static void I(global)(Symbol p) {$/;"	f	file:
globals	sym.c	/^Table globals     = &ids;$/;"	v
hascall	expr.c	/^int hascall(Tree p) {$/;"	f
hasproto	types.c	/^int hasproto(Type ty) {$/;"	f
head	gen.c	/^Node head;$/;"	v
header	alloc.c	/^union header {$/;"	u	file:
hlink	dag.c	/^	struct dag *hlink;$/;"	m	struct:dag
html	symbolic.c	/^static int off, maxoff, uid = 0, verbose = 0, html = 0;$/;"	v	file:
icon	lex.c	/^static Symbol icon(unsigned long n, int overflow, int base) {$/;"	f	file:
idempotent	simp.c	51;"	d	file:
identifiers	sym.c	/^Table identifiers = &ids;$/;"	v
identity	simp.c	26;"	d	file:
ids	sym.c	/^	ids = { GLOBAL },$/;"	v	file:
ids	tree.c	/^} ids[500];			\/* if ids[i].node == p, then p's id is i *\/$/;"	v	file:
idtree	expr.c	/^Tree idtree(Symbol p) {$/;"	f
ifstmt	stmt.c	/^static void ifstmt(int lab, int loop, Swtch swp, int lev) {$/;"	f	file:
import	bytecode.c	/^static void I(import)(Symbol p) {$/;"	f	file:
import	null.c	/^static void I(import)(Symbol p) {}$/;"	f	file:
import	symbolic.c	/^static void I(import)(Symbol p) {$/;"	f	file:
incr	expr.c	/^Tree incr(int op, Tree v, Tree e) {$/;"	f
index	prof.c	/^		struct { unsigned int index:6,x:10,y:16; } be;$/;"	m	struct:callsite::coordinate::<anonymous>
index	prof.c	/^		struct { unsigned int y:16,x:10,index:6; } le;$/;"	m	struct:callsite::coordinate::<anonymous>
init	inits.c	/^void init(int argc, char *argv[]) {$/;"	f
init	pass2.c	/^void init(int argc, char *argv[]) {$/;"	f
initarray	init.c	/^static int initarray(int len, Type ty, int lev) {$/;"	f	file:
initchar	init.c	/^static int initchar(int len, Type ty) {$/;"	f	file:
initend	init.c	/^static void initend(int lev, char follow[]) {$/;"	f	file:
initfields	init.c	/^static int initfields(Field p, Field q) {$/;"	f	file:
initglobal	decl.c	/^static void initglobal(Symbol p, int flag) {$/;"	f	file:
initializer	init.c	/^Type initializer(Type ty, int lev) {$/;"	f
initstruct	init.c	/^static int initstruct(int len, Type ty, int lev) {$/;"	f	file:
initvalue	init.c	/^static Tree initvalue(Type ty) {$/;"	f	file:
input_init	input.c	/^void input_init(int argc, char *argv[]) {$/;"	f
install	sym.c	/^Symbol install(const char *name, Table *tpp, int level, int arena) {$/;"	f
intconst	sym.c	/^Symbol intconst(int n) {$/;"	f
interface	pass2.c	/^static void interface(rcc_interface_ty in) {$/;"	f	file:
interfaces	asdl.c	/^static list_ty interfaces;$/;"	v	file:
intexpr	simp.c	/^int intexpr(int tok, int n) {$/;"	f
inttype	types.c	/^Type inttype;			\/* signed int *\/$/;"	v
iscall	dag.c	5;"	d	file:
iscallb	enode.c	/^int iscallb(Tree e) {$/;"	f
isfield	types.c	/^static Field isfield(const char *name, Field flist) {$/;"	f	file:
isnullptr	enode.c	/^static int isnullptr(Tree e) {$/;"	f	file:
ispow2	simp.c	/^int ispow2(unsigned long u) {$/;"	f
isvoidptr	enode.c	12;"	d	file:
itemmap	pass2.c	/^static void **itemmap;$/;"	v	file:
items	pass2.c	/^static rcc_item_ty *items;$/;"	v	file:
jump	stmt.c	/^Node jump(int lab) {$/;"	f
kill	dag.c	/^static void kill(Symbol p) {$/;"	f	file:
kind	error.c	/^char kind[] = {$/;"	v
l	alloc.c	/^	long l;$/;"	m	union:align
labelnode	dag.c	/^static void labelnode(int lab) {$/;"	f	file:
labels	sym.c	/^Table labels;$/;"	v
le	prof.c	/^		struct { unsigned int y:16,x:10,index:6; } le;$/;"	m	union:callsite::coordinate
len	string.c	/^	int len;$/;"	m	struct:string
length	list.c	/^int length(List list) {$/;"	f
level	sym.c	/^	int level;$/;"	m	struct:table
level	sym.c	/^int level = GLOBAL;$/;"	v
limit	alloc.c	/^	char *limit;$/;"	m	struct:block
limit	input.c	/^unsigned char *limit;	\/* points to last character + 1 *\/$/;"	v
line	input.c	/^char *line;		\/* current line *\/$/;"	v
linearize	gen.c	/^static void linearize(Node p, Node next) {$/;"	f	file:
lineno	input.c	/^int lineno;		\/* line number of current line *\/$/;"	v
link	prof.c	/^	struct func *link;$/;"	m	struct:func
link	profio.c	/^			struct caller *link;	\/* link to next caller *\/$/;"	m	struct:file::func::caller
link	profio.c	/^		struct func *link;		\/* link to next function *\/$/;"	m	struct:file::func
link	profio.c	/^	struct file *link;		\/* link to next file *\/$/;"	m	struct:file
link	string.c	/^	struct string *link;$/;"	m	struct:string
link	sym.c	/^		struct entry *link;$/;"	m	struct:table::entry
link	types.c	/^	struct entry *link;$/;"	m	struct:entry
list	dag.c	/^static void list(Node p) {$/;"	f	file:
listnodes	dag.c	/^Node listnodes(Tree tp, int tlab, int flab) {$/;"	f
local	bytecode.c	/^static void I(local)(Symbol p) {$/;"	f	file:
local	null.c	/^static void I(local)(Symbol p) {}$/;"	f	file:
local	symbolic.c	/^static void I(local)(Symbol p) {$/;"	f	file:
localaddr	stmt.c	/^static Symbol localaddr(Tree p) {$/;"	f	file:
loci	sym.c	/^List loci, symbols;$/;"	v
locus	sym.c	/^void locus(Table tp, Coordinate *cp) {$/;"	f
longdouble	types.c	/^Type longdouble;		\/* long double *\/$/;"	v
longlong	types.c	/^Type longlong;			\/* long long *\/$/;"	v
longtype	types.c	/^Type longtype;			\/* long *\/$/;"	v
lookup	sym.c	/^Symbol lookup(const char *name, Table tp) {$/;"	f
ltov	list.c	/^void *ltov(List *list, unsigned arena) {$/;"	f
lvalue	expr.c	/^Tree lvalue(Tree p) {$/;"	f
main	2html.c	/^int main(int argc, char *argv[]) {$/;"	f
main	main.c	/^int main(int argc, char *argv[]) {$/;"	f
main	pass2.c	/^int main(int argc, char *argv[]) {$/;"	f
main_init	main.c	/^void main_init(int argc, char *argv[]) {$/;"	f
main_init	pass2.c	/^void main_init(int argc, char *argv[]) {$/;"	f
map	lex.c	/^static unsigned char map[256] = { \/* 000 nul *\/	0,$/;"	v	file:
map	prof.c	/^struct map {		\/* source code map; 200 coordinates\/map *\/$/;"	s	file:
maplist	prof.c	/^static List maplist;	\/* list of struct map *'s *\/$/;"	v	file:
maxargoffset	gen.c	/^int maxargoffset;$/;"	v
maxlevel	types.c	/^static int maxlevel;$/;"	v	file:
maxoff	symbolic.c	/^static int off, maxoff, uid = 0, verbose = 0, html = 0;$/;"	v	file:
maxoffset	gen.c	/^int maxoffset;$/;"	v
mayrecalc	gen.c	/^int mayrecalc(Node p) {$/;"	f
mk_real	asdl.c	/^static rcc_real_ty mk_real(int size, Value v) {$/;"	f	file:
mk_symbol	asdl.c	/^static rcc_symbol_ty mk_symbol(Symbol p) {$/;"	f	file:
mkactual	gen.c	/^int mkactual(int align, int size) {$/;"	f
mkauto	gen.c	/^void mkauto(Symbol p) {$/;"	f
mkreg	gen.c	/^Symbol mkreg(char *fmt, int n, int mask, int set) {$/;"	f
mkstr	sym.c	/^Symbol mkstr(char *str) {$/;"	f
mksymbol	sym.c	/^Symbol mksymbol(int sclass, const char *name, Type ty) {$/;"	f
mkwildcard	gen.c	/^Symbol mkwildcard(Symbol *syms) {$/;"	f
move	gen.c	/^int move(Node p) {$/;"	f
moveself	gen.c	/^static int moveself(Node p) {$/;"	f	file:
muld	simp.c	/^static int muld(double x, double y, double min, double max, int needconst) {$/;"	f	file:
muli	simp.c	/^static int muli(long x, long y, long min, long max, int needconst) {$/;"	f	file:
multree	enode.c	/^static Tree multree(int op, Tree l, Tree r) {$/;"	f	file:
name	prof.c	/^	char *file, *name;$/;"	m	struct:callsite
name	prof.c	/^	char *name;$/;"	m	struct:func
name	profio.c	/^			char *name;		\/* caller's name *\/$/;"	m	struct:file::func::caller
name	profio.c	/^		char *name;			\/* function name *\/$/;"	m	struct:file::func
name	profio.c	/^	char *name;			\/* file name *\/$/;"	m	struct:file
ncalled	prof.c	/^int ncalled = -1;	\/* #times prof.out says current function was called *\/$/;"	v
needconst	simp.c	/^int needconst;$/;"	v
newarray	alloc.c	/^void *newarray(unsigned long m, unsigned long n, unsigned a) {$/;"	f
newfield	types.c	/^Field newfield(char *name, Type ty, Type fty) {$/;"	f
newnode	dag.c	/^Node newnode(int op, Node l, Node r, Symbol sym) {$/;"	f
newstruct	types.c	/^Type newstruct(int op, char *tag) {$/;"	f
newtemp	sym.c	/^Symbol newtemp(int sclass, int tc, int size) {$/;"	f
next	alloc.c	/^	struct block *next;$/;"	m	struct:block
nextid	2html.c	/^static int nextid;$/;"	v	file:
nextline	input.c	/^void nextline(void) {$/;"	f
nid	tree.c	/^static int nid = 1;		\/* identifies trees & nodes in debugging output *\/$/;"	v	file:
node	dag.c	/^	struct node node;$/;"	m	struct:dag
node	dag.c	/^static Node node(int op, Node l, Node r, Symbol sym) {$/;"	f	file:
node	tree.c	/^	Tree node;$/;"	m	struct:nodeid
nodecount	dag.c	/^int nodecount;$/;"	v
nodeid	tree.c	/^int nodeid(Tree p) {$/;"	f
nodeid	tree.c	/^static struct nodeid {$/;"	s	file:
notarget	gen.c	/^int notarget(Node p) {$/;"	f
npoints	prof.c	/^int npoints;		\/* # of execution points if -b specified *\/$/;"	v
ntypes	stab.c	/^static int ntypes;$/;"	v	file:
nuids	pass2.c	/^static int nuids;$/;"	v	file:
nullIR	null.c	/^Interface nullIR = {$/;"	v
nullcall	expr.c	/^Tree nullcall(Type pty, Symbol f, Tree p, Tree e) {$/;"	f
nullcheck	expr.c	/^static Tree nullcheck(Tree p) {$/;"	f	file:
off	symbolic.c	/^static int off, maxoff, uid = 0, verbose = 0, html = 0;$/;"	v	file:
offset	gen.c	/^int offset;$/;"	v
oldparam	decl.c	/^static void oldparam(Symbol p, void *cl) {$/;"	f	file:
oper	expr.c	/^static int oper[] = {$/;"	v	file:
opname	tree.c	/^char *opname(int op) {$/;"	f
optree	enode.c	/^Tree (*optree[])(int, Tree, Tree) = {$/;"	v
outd	output.c	/^static char *outd(long n, FILE *f, char *bp) {$/;"	f	file:
outs	output.c	/^static char *outs(const char *str, FILE *f, char *bp) {$/;"	f	file:
outtype	types.c	/^void outtype(Type ty, FILE *f) {$/;"	f
outu	output.c	/^static char *outu(unsigned long n, int base, FILE *f, char *bp) {$/;"	f	file:
p	alloc.c	/^	char *p;$/;"	m	union:align
parameters	decl.c	/^static Symbol *parameters(Type fty) {$/;"	f	file:
parseflags	gen.c	/^void parseflags(int argc, char *argv[]) {$/;"	f
pending	asdl.c	/^static Symbol pending = NULL;$/;"	v	file:
pickle	asdl.c	/^static rcc_program_ty pickle;$/;"	v	file:
pointer	expr.c	/^Tree pointer(Tree p) {$/;"	f
pointersym	types.c	/^static Symbol pointersym;$/;"	v	file:
postfix	expr.c	/^static Tree postfix(Tree p) {$/;"	f	file:
ppnumber	lex.c	/^static void ppnumber(char *which) {$/;"	f	file:
pragma	input.c	/^static void pragma(void) {$/;"	f	file:
prec	expr.c	/^static char prec[] = {$/;"	v	file:
prelabel	gen.c	/^static void prelabel(Node p) {$/;"	f	file:
prev	pass2.c	/^	struct block *prev;$/;"	m	struct:block
previous	sym.c	/^	Table previous;$/;"	m	struct:table
primary	expr.c	/^static Tree primary(void) {$/;"	f	file:
print	output.c	/^void print(const char *fmt, ...) {$/;"	f
printdag	dag.c	/^void printdag(Node p, int fd) {$/;"	f
printdag1	dag.c	/^static void printdag1(Node p, int fd, int lev) {$/;"	f	file:
printdecl	types.c	/^void printdecl(Symbol p, Type ty) {$/;"	f
printed	tree.c	/^	int printed;$/;"	m	struct:nodeid
printed	tree.c	/^int *printed(int id) {$/;"	f
printnode	dag.c	/^static void printnode(Node p, int fd, int lev) {$/;"	f	file:
printproto	types.c	/^void printproto(Symbol p, Symbol callee[]) {$/;"	f
printtoken	error.c	/^static void printtoken(void) {$/;"	f	file:
printtree	tree.c	/^void printtree(Tree p, int fd) {$/;"	f
printtree1	tree.c	/^static void printtree1(Tree p, int fd, int lev) {$/;"	f	file:
printtype	types.c	/^void printtype(Type ty, int fd) {$/;"	f
process	profio.c	/^int process(char *file) {$/;"	f
prof_init	prof.c	/^void prof_init(int argc, char *argv[]) {$/;"	f
progbeg	bytecode.c	/^static void I(progbeg)(int argc, char *argv[]) {}$/;"	f	file:
progbeg	null.c	/^static void I(progbeg)(int argc, char *argv[]) {}$/;"	f	file:
progbeg	symbolic.c	/^static void I(progbeg)(int argc, char *argv[]) {$/;"	f	file:
progend	bytecode.c	/^static void I(progend)(void) {}$/;"	f	file:
progend	null.c	/^static void I(progend)(void) {}$/;"	f	file:
progend	symbolic.c	/^static void I(progend)(void) {$/;"	f	file:
program	decl.c	/^void program(void) {$/;"	f
promote	types.c	/^Type promote(Type ty) {$/;"	f
prtype	types.c	/^static void prtype(Type ty, FILE *f, int indent, unsigned mark) {$/;"	f	file:
prune	dag.c	/^static Node prune(Node forest) {$/;"	f	file:
prune	gen.c	/^static Node *prune(Node p, Node pp[]) {$/;"	f	file:
prunetemps	dag.c	/^int prunetemps = -1;$/;"	v
ptr	types.c	/^Type ptr(Type ty) {$/;"	f
put	asdl.c	/^static void put(rcc_interface_ty node) {$/;"	f	file:
putreg	gen.c	/^static void putreg(Symbol r) {$/;"	f	file:
qual	types.c	/^Type qual(int op, Type ty) {$/;"	f
ralloc	gen.c	/^static void ralloc(Node p) {$/;"	f	file:
range	gen.c	/^int range(Node p, int lo, int hi) {$/;"	f
rcsid	2html.c	/^static char rcsid[] = "$Id: asdl.nw,v 1.24 1998\/09\/21 21:05:15 drh Exp $";$/;"	v	file:
rcsid	asdl.c	/^static char rcsid[] = "$Id: asdl.nw,v 1.24 1998\/09\/21 21:05:15 drh Exp $";$/;"	v	file:
rcsid	bytecode.c	/^static char rcsid[] = "$Id: inter.nw,v 2.35 1998\/09\/10 21:47:37 drh Exp $";$/;"	v	file:
rcsid	dag.c	/^static char rcsid[] = "$Id: dag.nw,v 2.30 1998\/09\/21 21:24:47 drh Exp $";$/;"	v	file:
rcsid	decl.c	/^static char rcsid[] = "$Id: decl.nw,v 2.24 1998\/08\/28 00:06:50 drh Exp $";$/;"	v	file:
rcsid	enode.c	/^static char rcsid[] = "$Id: enode.nw,v 2.15 1998\/07\/02 00:23:01 drh Exp $";$/;"	v	file:
rcsid	error.c	/^static char rcsid[] = "$Id: error.nw,v 2.6 1998\/04\/30 20:41:01 drh Exp $";$/;"	v	file:
rcsid	event.c	/^static char rcsid[] = "$Id: event.nw,v 1.8 1997\/02\/16 21:13:34 drh Exp $";$/;"	v	file:
rcsid	expr.c	/^static char rcsid[] = "$Id: expr.nw,v 2.29 1998\/09\/09 00:43:24 drh Exp $";$/;"	v	file:
rcsid	gen.c	/^static char rcsid[] = "$Id: gen.nw,v 2.36 1998\/09\/09 00:44:23 drh Exp $";$/;"	v	file:
rcsid	init.c	/^static char rcsid[] = "$Id: init.nw,v 2.5 1998\/04\/30 20:41:04 drh Exp $";$/;"	v	file:
rcsid	input.c	/^static char rcsid[] = "$Id: input.nw,v 2.10 1997\/09\/17 17:13:10 drh Exp $";$/;"	v	file:
rcsid	lex.c	/^static char rcsid[] = "$Id: lex.nw,v 2.18 1998\/05\/26 20:36:20 drh Exp $";$/;"	v	file:
rcsid	list.c	/^static char rcsid[] = "$Id: list.nw,v 2.1 1995\/07\/17 14:31:52 drh Exp $";$/;"	v	file:
rcsid	main.c	/^static char rcsid[] = "$Name: v4_1 $($Id: main.nw,v 4.17 1997\/09\/25 23:07:49 drh Exp $)";$/;"	v	file:
rcsid	null.c	/^static char rcsid[] = "$Id: inter.nw,v 2.35 1998\/09\/10 21:47:37 drh Exp $";$/;"	v	file:
rcsid	output.c	/^static char rcsid[] = "$Id: output.nw,v 2.14 1998\/09\/03 16:25:13 drh Exp $";$/;"	v	file:
rcsid	pass2.c	/^static char rcsid[] = "$Id: asdl.nw,v 1.24 1998\/09\/21 21:05:15 drh Exp $";$/;"	v	file:
rcsid	prof.c	/^static char rcsid[] = "$Id: prof.nw,v 2.11 1998\/06\/26 22:38:04 drh Exp $";$/;"	v	file:
rcsid	profio.c	/^static char rcsid[] = "$Id: profio.nw,v 2.4 1997\/05\/02 21:13:11 drh Exp $";$/;"	v	file:
rcsid	simp.c	/^static char rcsid[] = "$Id: simp.nw,v 2.18 1998\/07\/02 00:23:05 drh Exp $";$/;"	v	file:
rcsid	stab.c	/^static char rcsid[] = "$Id: sparc.nw,v 2.31 1998\/09\/10 22:40:19 drh Exp $";$/;"	v	file:
rcsid	stmt.c	/^static char rcsid[] = "$Id: stmt.nw,v 2.12 1998\/06\/29 21:57:35 drh Exp $";$/;"	v	file:
rcsid	string.c	/^static char rcsid[] = "$Id: string.nw,v 1.9 1997\/05\/02 20:32:31 drh Exp $";$/;"	v	file:
rcsid	sym.c	/^static char rcsid[] = "$Id: sym.nw,v 2.17 1997\/12\/17 23:59:12 drh Exp $";$/;"	v	file:
rcsid	symbolic.c	/^static char rcsid[] = "$Id: inter.nw,v 2.35 1998\/09\/10 21:47:37 drh Exp $";$/;"	v	file:
rcsid	trace.c	/^static char rcsid[] = "$Id: trace.nw,v 2.6 1997\/09\/05 20:36:26 drh Exp $";$/;"	v	file:
rcsid	tree.c	/^static char rcsid[] = "$Id: tree.nw,v 2.8 1998\/09\/03 16:49:01 drh Exp $";$/;"	v	file:
rcsid	types.c	/^static char rcsid[] = "$Id: types.nw,v 2.31 1998\/05\/26 20:50:28 drh Exp $";$/;"	v	file:
reachable	stmt.c	/^int reachable(int kind) {$/;"	f
readsreg	gen.c	5;"	d	file:
reduce	gen.c	/^static void reduce(Node p, int nt) {$/;"	f	file:
refinc	expr.c	/^float refinc = 1.0;$/;"	v
regcount	decl.c	/^static int regcount;$/;"	v	file:
registers	decl.c	/^static List autos, registers;$/;"	v	file:
regloc	gen.c	/^unsigned regloc(Symbol p) {$/;"	f
relink	gen.c	11;"	d	file:
relocate	sym.c	/^Symbol relocate(const char *name, Table src, Table dst) {$/;"	f
replace	dag.c	/^static Node replace(Node p) {$/;"	f	file:
reprune	gen.c	/^static int reprune(Node *pp, int k, int n, Node p) {$/;"	f	file:
requate	gen.c	/^static int requate(Node q) {$/;"	f	file:
reset	dag.c	/^static void reset(void) {$/;"	f	file:
resynch	input.c	/^static void resynch(void) {$/;"	f	file:
retcode	stmt.c	/^void retcode(Tree p) {$/;"	f
retv	decl.c	/^Symbol retv;		\/* return value location for structs *\/$/;"	v
retype	expr.c	/^Tree retype(Tree p, Type ty) {$/;"	f
reuse	gen.c	/^static Node reuse(Node p, int nt) {$/;"	f	file:
rewrite	gen.c	/^static void rewrite(Node p) {$/;"	f	file:
rightkid	expr.c	/^Tree rightkid(Tree p) {$/;"	f
rmtypes	types.c	/^void rmtypes(int lev) {$/;"	f
root	tree.c	/^Tree root(Tree p) {$/;"	f
root1	tree.c	/^static Tree root1(Tree p) {$/;"	f	file:
rtarget	gen.c	/^void rtarget(Node p, int n, Symbol r) {$/;"	f
rvalue	expr.c	/^Tree rvalue(Tree p) {$/;"	f
salign	gen.c	/^int dalign, salign;$/;"	v
scatter	string.c	/^static int scatter[] = {	\/* map characters to random values *\/$/;"	v	file:
scon	lex.c	/^static void *scon(int q, void *put(int c, void *cl), void *cl) {$/;"	f	file:
segment	bytecode.c	/^static void I(segment)(int n) {$/;"	f	file:
segment	null.c	/^static void I(segment)(int s) {}$/;"	f	file:
segment	symbolic.c	/^static void I(segment)(int s) {$/;"	f	file:
setreg	gen.c	/^void setreg(Node p, Symbol r) {$/;"	f
setsrc	gen.c	7;"	d	file:
sfoldcnst	simp.c	43;"	d	file:
shorttype	types.c	/^Type shorttype;			\/* signed short int *\/$/;"	v
shtree	enode.c	/^Tree shtree(int op, Tree l, Tree r) {$/;"	f
signedchar	types.c	/^Type signedchar;		\/* signed char *\/$/;"	v
signedint	types.c	/^Type signedint(Type ty) {$/;"	f
signedptr	types.c	/^Type signedptr;			\/* signed type to hold void* *\/$/;"	v
simplify	simp.c	/^Tree simplify(int op, Type ty, Tree l, Tree r) {$/;"	f
size	prof.c	/^	int size;$/;"	m	struct:map
size	profio.c	/^	int size;			\/* size of counts[] *\/$/;"	m	struct:file
skipto	error.c	/^void skipto(int tok, char set[]) {$/;"	f
space	bytecode.c	/^static void I(space)(int n) {$/;"	f	file:
space	null.c	/^static void I(space)(int n) {}$/;"	f	file:
space	symbolic.c	/^static void I(space)(int n) {$/;"	f	file:
specifier	decl.c	/^static Type specifier(int *sclass) {$/;"	f	file:
spill	gen.c	/^void spill(unsigned mask, int n, Node here) {$/;"	f
spillee	gen.c	/^static Symbol spillee(Symbol set, unsigned mask[], Node here) {$/;"	f	file:
spillr	gen.c	/^static void spillr(Symbol r, Node here) {$/;"	f	file:
src	lex.c	/^Coordinate src;		\/* current source coordinate *\/$/;"	v
src	prof.c	/^	union coordinate src;$/;"	m	struct:func
srcfp	main.c	/^static FILE *srcfp;		\/* stream for current file, if non-NULL *\/$/;"	v	file:
srcpos	main.c	/^static int srcpos;		\/* position of srcfp, if srcfp is non-NULL *\/$/;"	v	file:
stabIR	main.c	/^static Interface stabIR;$/;"	v	file:
stabblock	null.c	/^static void I(stabblock)(int brace, int lev, Symbol *p) {}$/;"	f	file:
stabblock	stab.c	/^void stabblock(int brace, int lev, Symbol *p) {$/;"	f
stabblock	symbolic.c	/^static void I(stabblock)(int brace, int lev, Symbol *p) {}$/;"	f	file:
stabend	main.c	/^static void stabend(Coordinate *cp, Symbol p, Coordinate **cpp, Symbol *sp, Symbol *stab) {$/;"	f	file:
stabend	null.c	/^static void I(stabend)(Coordinate *cp, Symbol p, Coordinate **cpp, Symbol *sp, Symbol *stab) {}$/;"	f	file:
stabend	stab.c	/^void stabend(Coordinate *cp, Symbol p, Coordinate **cpp, Symbol *sp, Symbol *stab) {$/;"	f
stabend	symbolic.c	/^static void I(stabend)(Coordinate *cp, Symbol p, Coordinate **cpp, Symbol *sp, Symbol *stab) {$/;"	f	file:
stabfend	null.c	/^static void I(stabfend)(Symbol p, int lineno) {}$/;"	f	file:
stabfend	stab.c	/^void stabfend(Symbol p, int lineno) {}$/;"	f
stabfend	symbolic.c	/^static void I(stabfend)(Symbol p, int lineno) {}$/;"	f	file:
stabinit	null.c	/^static void I(stabinit)(char *file, int argc, char *argv[]) {}$/;"	f	file:
stabinit	stab.c	/^void stabinit(char *file, int argc, char *argv[]) {$/;"	f
stabinit	symbolic.c	/^static void I(stabinit)(char *file, int argc, char *argv[]) {}$/;"	f	file:
stabline	bytecode.c	/^static void I(stabline)(Coordinate *cp) {$/;"	f	file:
stabline	main.c	/^static void stabline(Coordinate *cp) {$/;"	f	file:
stabline	null.c	/^static void I(stabline)(Coordinate *cp) {}$/;"	f	file:
stabline	stab.c	/^void stabline(Coordinate *cp) {$/;"	f
stabline	symbolic.c	/^static void I(stabline)(Coordinate *cp) {$/;"	f	file:
stabprefix	stab.c	/^char *stabprefix = "L";$/;"	v
stabsym	null.c	/^static void I(stabsym)(Symbol p) {}$/;"	f	file:
stabsym	stab.c	/^void stabsym(Symbol p) {$/;"	f
stabsym	symbolic.c	/^static void I(stabsym)(Symbol p) {}$/;"	f	file:
stabtype	null.c	/^static void I(stabtype)(Symbol p) {}$/;"	f	file:
stabtype	stab.c	/^void stabtype(Symbol p) {$/;"	f
stabtype	symbolic.c	/^static void I(stabtype)(Symbol p) {}$/;"	f	file:
statement	stmt.c	/^void statement(int loop, Swtch swp, int lev) {$/;"	f
stmtlabel	stmt.c	/^static void stmtlabel(void) {$/;"	f	file:
stmtlabs	stmt.c	/^Table stmtlabs;$/;"	v
str	string.c	/^	char *str;$/;"	m	struct:string
string	asdl.c	/^char *string(const char *str) {$/;"	f
string	string.c	/^char *string(const char *str) {$/;"	f
string	string.c	/^static struct string {$/;"	s	file:
stringd	asdl.c	/^char *stringd(long n) {$/;"	f
stringd	string.c	/^char *stringd(long n) {$/;"	f
stringf	output.c	/^char *stringf(const char *fmt, ...) {$/;"	f
stringn	asdl.c	/^char *stringn(const char *str, int len) {$/;"	f
stringn	string.c	/^char *stringn(const char *str, int len) {$/;"	f
structdcl	decl.c	/^static Type structdcl(int op) {$/;"	f	file:
subd	simp.c	/^static int subd(double x, double y, double min, double max, int needconst) {$/;"	f	file:
subi	simp.c	/^static int subi(long x, long y, long min, long max, int needconst) {$/;"	f	file:
subtree	enode.c	/^static Tree subtree(int op, Tree l, Tree r) {$/;"	f	file:
super	expr.c	/^static Type super(Type ty) {$/;"	f	file:
swap	gen.c	/^int swap;$/;"	v
swcode	stmt.c	/^void swcode(Swtch swp, int b[], int lb, int ub) {$/;"	f
swgen	stmt.c	/^void swgen(Swtch swp) {$/;"	f
swstmt	stmt.c	/^static void swstmt(int loop, int lab, int lev) {$/;"	f	file:
swtoseg	init.c	/^void swtoseg(int seg) {$/;"	f
sym	sym.c	/^		struct symbol sym;$/;"	m	struct:table::entry
symbolic64IR	symbolic.c	/^Interface symbolic64IR = {$/;"	v
symbolicIR	symbolic.c	/^Interface symbolicIR = {$/;"	v
symbols	sym.c	/^List loci, symbols;$/;"	v
symboluid	asdl.c	/^static int symboluid(Symbol p) {$/;"	f	file:
t	lex.c	/^int t;$/;"	v
table	sym.c	/^Table table(Table tp, int level) {$/;"	f
table	sym.c	/^struct table {$/;"	s	file:
tail	dag.c	/^static Node *tail;$/;"	v	file:
tail	symbolic.c	/^static Node *tail;$/;"	v	file:
tempid	sym.c	/^static int tempid;$/;"	v	file:
temporary	sym.c	/^Symbol temporary(int scls, Type ty) {$/;"	f
temps	asdl.c	/^static Symbol temps;$/;"	v	file:
test	error.c	/^void test(int tok, char set[]) {$/;"	f
texpr	tree.c	/^Tree texpr(Tree (*f)(int), int tok, int a) {$/;"	f
tmask	gen.c	/^unsigned tmask[2];$/;"	v
tmpnode	dag.c	/^static Node tmpnode(Node p) {$/;"	f	file:
tnode	decl.c	/^static Type tnode(int op, Type type) {$/;"	f	file:
token	lex.c	/^char *token;		\/* current token *\/$/;"	v
trace_init	trace.c	/^void trace_init(int argc, char *argv[]) {$/;"	f
tracecall	trace.c	/^static void tracecall(Symbol printer, Symbol f) {$/;"	f	file:
tracefinis	trace.c	/^static void tracefinis(Symbol printer) {$/;"	f	file:
tracereturn	trace.c	/^static void tracereturn(Symbol printer, Symbol f, Tree e) {$/;"	f	file:
tracevalue	trace.c	/^static void tracevalue(Tree e, int lev) {$/;"	f	file:
tree	tree.c	/^Tree tree(int op, Type type, Tree left, Tree right) {$/;"	f
tsym	lex.c	/^Symbol tsym;		\/* symbol table entry for current token *\/$/;"	v
ttob	types.c	/^int ttob(Type ty) {$/;"	f
tval	lex.c	/^static struct symbol tval;$/;"	v	file:
type	types.c	/^	struct type type;$/;"	m	struct:entry
type	types.c	/^static Type type(int op, Type ty, int size, int align, void *sym) {$/;"	f	file:
type_init	types.c	/^void type_init(int argc, char *argv[]) {$/;"	f
typeerror	enode.c	/^void typeerror(int op, Tree l, Tree r) {$/;"	f
typename	decl.c	/^Type typename(void) {$/;"	f
types	sym.c	/^Table types       = &tys;$/;"	v
typestab	dag.c	/^static void typestab(Symbol p, void *cl) {$/;"	f	file:
typestab	main.c	/^static void typestab(Symbol p, void *cl) {$/;"	f	file:
typestring	types.c	/^char *typestring(Type ty, char *str) {$/;"	f
typetable	types.c	/^} *typetable[128];$/;"	v	file:
typeuid	asdl.c	/^static int typeuid(Type ty) {$/;"	f	file:
tys	sym.c	/^	tys = { GLOBAL };$/;"	v	file:
u	prof.c	/^	union coordinate u[200];$/;"	m	struct:map
u	prof.c	/^	} u;$/;"	m	struct:callsite
ufoldcnst	simp.c	42;"	d	file:
uid	symbolic.c	/^static int off, maxoff, uid = 0, verbose = 0, html = 0;$/;"	v	file:
uid2symbol	pass2.c	/^static Symbol uid2symbol(int uid) {$/;"	f	file:
uid2type	pass2.c	/^static void *uid2type(int uid) {$/;"	f	file:
unary	expr.c	/^static Tree unary(void) {$/;"	f	file:
undag	dag.c	/^static Node undag(Node forest) {$/;"	f	file:
unlist	dag.c	/^static void unlist(void) {$/;"	f	file:
unsignedchar	types.c	/^Type unsignedchar;		\/* unsigned char *\/$/;"	v
unsignedlong	types.c	/^Type unsignedlong;		\/* unsigned long int *\/$/;"	v
unsignedlonglong	types.c	/^Type unsignedlonglong;		\/* unsigned long long int *\/$/;"	v
unsignedptr	types.c	/^Type unsignedptr;		\/* unsigned type to hold void* *\/$/;"	v
unsignedshort	types.c	/^Type unsignedshort;		\/* unsigned short int *\/$/;"	v
unsignedtype	types.c	/^Type unsignedtype;		\/* unsigned int *\/$/;"	v
use	sym.c	/^void use(Symbol p, Coordinate src) {$/;"	f
usedmask	gen.c	/^unsigned usedmask[2];$/;"	v
uses	gen.c	/^static int uses(Node p, Regnode rn) {$/;"	f	file:
value	expr.c	/^Tree value(Tree p) {$/;"	f
variadic	types.c	/^int variadic(Type ty) {$/;"	f
vcall	enode.c	/^Tree vcall(Symbol func, Type ty, ...) {$/;"	f
verbose	pass2.c	/^static int verbose = 1;$/;"	v	file:
verbose	symbolic.c	/^static int off, maxoff, uid = 0, verbose = 0, html = 0;$/;"	v	file:
vfprint	output.c	/^void vfprint(FILE *f, char *bp, const char *fmt, va_list ap) {$/;"	f
visit	asdl.c	/^static rcc_node_ty visit(Node p) {$/;"	f	file:
visit	dag.c	/^static Node visit(Node p, int listed) {$/;"	f	file:
visit	pass2.c	/^static Node visit(rcc_node_ty node) {$/;"	f	file:
visit	symbolic.c	/^static int visit(Node p, int n) {$/;"	f	file:
vmask	gen.c	/^unsigned vmask[2];$/;"	v
voidptype	types.c	/^Type voidptype;			\/* void* *\/$/;"	v
voidtype	types.c	/^Type voidtype;			\/* basic types: void *\/$/;"	v
vtoa	sym.c	/^char *vtoa(Type ty, Value v) {$/;"	f
walk	dag.c	/^void walk(Tree tp, int tlab, int flab) {$/;"	f
warn	tree.c	/^static int warn;$/;"	v	file:
warning	error.c	/^void warning(const char *fmt, ...) {$/;"	f
wcbuf	lex.c	/^static unsigned int wcbuf[BUFSIZE+1];$/;"	v	file:
wcput	lex.c	/^static void *wcput(int c, void *cl) {$/;"	f	file:
wflag	error.c	/^int wflag;		\/* != 0 to suppress warning messages *\/$/;"	v
where	tree.c	/^int where = STMT;$/;"	v
whilestmt	stmt.c	/^static void whilestmt(int lab, Swtch swp, int lev) {$/;"	f	file:
widechar	types.c	/^Type widechar;			\/* unsigned type that represents wchar_t *\/$/;"	v
x	prof.c	/^		struct { unsigned int index:6,x:10,y:16; } be;$/;"	m	struct:callsite::coordinate::<anonymous>
x	prof.c	/^		struct { unsigned int y:16,x:10,index:6; } le;$/;"	m	struct:callsite::coordinate::<anonymous>
x	profio.c	/^			int x, y;$/;"	m	struct:file::func::caller
x	profio.c	/^	int x, y;			\/* source coordinate *\/$/;"	m	struct:count
xcvtcnst	simp.c	18;"	d	file:
xfoldcnst	simp.c	12;"	d	file:
xref	main.c	/^int xref;		\/* != 0 for cross-reference data *\/$/;"	v
xref	pass2.c	/^int xref;		\/* != 0 for cross-reference data *\/$/;"	v
xx	2html.c	20;"	d	file:
xx	2html.c	26;"	d	file:
xx	2html.c	34;"	d	file:
xx	2html.c	40;"	d	file:
xx	2html.c	46;"	d	file:
xx	2html.c	52;"	d	file:
xx	2html.c	58;"	d	file:
xx	2html.c	63;"	d	file:
xx	2html.c	67;"	d	file:
xx	asdl.c	103;"	d	file:
xx	asdl.c	109;"	d	file:
xx	asdl.c	213;"	d	file:
xx	asdl.c	216;"	d	file:
xx	asdl.c	367;"	d	file:
xx	asdl.c	37;"	d	file:
xx	asdl.c	386;"	d	file:
xx	asdl.c	387;"	d	file:
xx	asdl.c	395;"	d	file:
xx	asdl.c	42;"	d	file:
xx	asdl.c	43;"	d	file:
xx	asdl.c	48;"	d	file:
xx	enode.c	16;"	d	file:
xx	error.c	9;"	d	file:
xx	expr.c	11;"	d	file:
xx	expr.c	494;"	d	file:
xx	expr.c	510;"	d	file:
xx	expr.c	6;"	d	file:
xx	output.c	105;"	d	file:
xx	pass2.c	163;"	d	file:
xx	pass2.c	169;"	d	file:
xx	pass2.c	182;"	d	file:
xx	pass2.c	199;"	d	file:
xx	pass2.c	201;"	d	file:
xx	pass2.c	219;"	d	file:
xx	pass2.c	598;"	d	file:
xx	pass2.c	616;"	d	file:
xx	symbolic.c	226;"	d	file:
xx	symbolic.c	252;"	d	file:
xx	symbolic.c	64;"	d	file:
xx	symbolic.c	87;"	d	file:
xx	types.c	102;"	d	file:
xx	types.c	116;"	d	file:
xx	types.c	118;"	d	file:
xx	types.c	133;"	d	file:
xx	types.c	147;"	d	file:
xx	types.c	160;"	d	file:
xx	types.c	163;"	d	file:
xx	types.c	170;"	d	file:
xx	types.c	384;"	d	file:
xx	types.c	388;"	d	file:
xx	types.c	449;"	d	file:
xx	types.c	479;"	d	file:
xxinit	types.c	/^static Type xxinit(int op, char *name, Metrics m) {$/;"	f	file:
y	prof.c	/^		struct { unsigned int index:6,x:10,y:16; } be;$/;"	m	struct:callsite::coordinate::<anonymous>
y	prof.c	/^		struct { unsigned int y:16,x:10,index:6; } le;$/;"	m	struct:callsite::coordinate::<anonymous>
y	profio.c	/^			int x, y;$/;"	m	struct:file::func::caller
y	profio.c	/^	int x, y;			\/* source coordinate *\/$/;"	m	struct:count
yy	2html.c	244;"	d	file:
yy	enode.c	17;"	d	file:
yy	error.c	10;"	d	file:
yy	expr.c	12;"	d	file:
yy	expr.c	7;"	d	file:
yy	output.c	106;"	d	file:
yyBEGIN	symbolic.c	/^static const char *yyBEGIN(const char *tag) {$/;"	f	file:
yyEND	symbolic.c	/^static void yyEND(const char *tag) {$/;"	f	file:
zerofield	simp.c	28;"	d	file:
