Introduction
============

This document describes how to add custom ops (user defined instructions)
to lcc and Oink. Because lcc does not support inline assembly we have to
apply a trick to achieve it. 


Step 1: find opcode space
=========================

Find space in the MIPS opcode space for the custom ops that you want to
add. Custom ops can have multiple operands but only one result. In order to
supply all operands, a custom op might be implemented by multiple instructions
that pass all operands to the functional unit where the last instruction
triggers the functional unit to start the operation.

Step 2: add patterns to minimips.md
===================================

Custom ops are generated by patterns of operations that are very unlikely to
occur in normal programs. An example of such a pattern is an integer load
of address 0x12344321 whose result is added to another integer and this result
is again subtracted from another integer. In minimips.md you have to specify
this pattern and tell what assembly code to generate for this pattern. Here
is the pattern for the described example:

	magic_addr: CNSTP4      "%a"   is_magic_addr(a)

	reg: SUBI4(reg, ADDI4(reg, INDIRI4(magic_addr)))        
			"\t.word (%c<<11)|(%0<<21)|(%1<<16)|0x31\n"

	int
	is_magic_addr (Node p)
	{
	  return (int) p->syms[0]->u.c.v.p == 0x12344321 ? 0 : LBURG_MAX;
	}

Notice that the pattern has two arguments (reg) which correspond to the
arguments of our custom op. When the pattern is detected, the compiler emits
the '.word' directive which assembles the instruction for the custom op. The
destination register (%c) and the two source registers (%0 and %1) are 
inserted at proper bit positions. Because we generate a '.word' directive 
instead of a new instruction, we don't have to modify the assembler that
translates the assembly code of lcc to binary code.

The patterns can have more than two register arguments and the assembly
string can contain multiple instructions separated by \n's to pass all
arguments to the functional units.

Step 3: compile lcc
===================

Check the BUILDDIR variable in 'makefile' and type 'make'

Step 4: modify Oink
===================

Find out where to add your instruction in one of the tables in decode_tables.h.
Replace the proper &&execute_DUMMY by your &&execute_MY_CUSTOM_OP. Add the
code to simulate your custom op to semantics.h. For example, to implement
a custom op that computes the average of its arguments:

	execute_MY_CUSTOM_OP:
	{
		RD = (RS + RT) / 2;

		UPDATE_PC();
		DONE;
	}

Step 5: compile Oink
====================

Type 'make oink'. Copy the resulting executable to your lccdir directory.

Step 6: use the custom ops
==========================

The easiest way to use a custom op is to define a macro that expands into
the pattern of operations that triggers generation of the custom op. For
our example pattern this corresponds to:

	#define average(a, b)       ((a) - ((b) + *(int *) 0x12344321))

Now the custom op can be used by simple using the macro:

	printf("average of 10 and 20 is %d\n", average(10, 20));

Compiling and simulating this with lcc and oink modified as explained above
should lead to the desired result.
