//void printtext(int x, int y, string String)
//{
//	//(x,y) is from the bottom left of the window
//	glMatrixMode(GL_PROJECTION);
//	glPushMatrix();
//	glLoadIdentity();
//	glOrtho(0, windowWidth, 0, windowHeight, -1.0f, 1.0f);
//	glMatrixMode(GL_MODELVIEW);
//	glPushMatrix();
//	glLoadIdentity();
//	glPushAttrib(GL_DEPTH_TEST);
//	glDisable(GL_DEPTH_TEST);
//	glRasterPos2i(x, y);
//	for (int i = 0; i<String.size(); i++)
//	{
//		glutBitmapCharacter(GLUT_BITMAP_9_BY_15, String[i]);
//	}
//	glPopAttrib();
//	glMatrixMode(GL_PROJECTION);
//	glPopMatrix();
//	glMatrixMode(GL_MODELVIEW);
//	glPopMatrix();
//}
//
//void drawtext(std::string keytext, int x, int y) {
//
//		//cout << "jow ik ga ze uitrpinten" << endl;
//		glRasterPos2f(900, 100);
//		glColor3f(0, 0, 0);
//	
//		for (char& c : keytext)
//		{
//			//cout << c << endl;
//			glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);
//		}
//
//	}








//float posy = posEnemy[1] + 	(dy / 15);
							//PointF BulletStart = { posTurret[0], (posTurret[1]) };
							//PointF BulletPos = bulletvector.at(i)->Move();
							//Bullet* but = new Bullet(BulletIntercept, posTurret);
							//Bullet* bullet = new Bullet(BulletIntercept,BulletStart);

							//Line* bulletline = new Line{ BulletPos , turretvector.at(i)->_position , color, lind };
							//drawList.push_back(bulletline);
						
							//bulletvector.push_back(bulletline);



						//}
						//no enemy in track
						//if(aimingId == 0) {
						//	cout << "jow ben heir" << endl;
						//	//get current pos of the first enemy
						//	PointF posEnemy = enenemyvector.front()->_current;


						//	Line* bulletline = new Line{ posEnemy, turretvector.at(i)->_position , color, lind };
						//	drawList.push_back(bulletline);
						//
						//	bulletvector.push_back(bulletline);
						//	//update track id of the turret
						//	turretvector.at(i)->Aim(enenemyvector.front()->_id);
						//}








//float dy = abs(posEnemy[1] - posTurret[1]);
//float dx = abs(posEnemy[0] - posTurret[0]);
//PointF posTurret = turretvector.at(i)->_position;










//if (nextCharYplus == '/' && Map[(curx + 2)][cury] == '/' && Map[(curx + 3)][cury] == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(0, 1);
//	cout << "Moving enemy up" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//
//	return;
//}
//// move 20 y pixels rght
//if (nextCharXplus == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(1, 0);
//	cout << "Moving enemy right" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//	return;
//}
////move 20 pixels down
//if (nextCharYmin == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(0, -1);
//	cout << "Moving enemy down" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//	return;
//}
////move 20 pixels left
//if (nextCharXmin == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(-1, 0);
//	cout << "Moving enemy left" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//	return;
//}
//else {
//	cout << "error" << endl;
//	cout << nextCharXplus << nextCharYplus << nextCharXmin << nextCharYmin << endl;
//	cout << curx << "  " << cury << endl;
//	return;
//}

//for (int x = 0; x < mapSizex; x++) {
//	for (int y = 0; y < mapSizey; y++) {
//		
//	}
//}
//PointF posEnemy = enenemyvector.at(i)->Move();
//cout << "Enemy id :" << endl;
//cout << enenemyvector.at(i)->_id << endl;
//cout << "Enemy health" << endl;
//cout << enenemyvector.at(i)->_health << endl;

		//if (CountLines == 0) {
		//	cout << "Storing map name" << endl;
		//	MapName = word;
		//	
		//	continue;
		//}
			
			//cout << "map contains :" << endl;
			//cout << Map[i][CountLines] << endl;
			//fieldMap[i, CountLines] = c;
			//fieldMap.insert( c, i, 2);	// = word.at(i);

//enenemyvector.at(i)->Update(posEnemy);
//r = enenemyvector.at(i)->_health;
//Circle* cirle = new Circle(posEnemy, color, r, seg);
//drawList.push_back(cirle);
//drawBullets(posEnemy, i);
//Bullet(posEnemy, i);
//draw the bullet

				//for (int x = 0; x < mapSizex; x++) {
				//	for (int y = 0; y < mapSizey; y++) {
				//		
				//	}
				//}
				//PointF posEnemy = enenemyvector.at(i)->Move();
				//cout << "Enemy id :" << endl;
				//cout << enenemyvector.at(i)->_id << endl;
				//cout << "Enemy health" << endl;
				//cout << enenemyvector.at(i)->_health << endl;

				//enenemyvector.at(i)->Update(posEnemy);
				//r = enenemyvector.at(i)->_health;
				//Circle* cirle = new Circle(posEnemy, color, r, seg);
				//drawList.push_back(cirle);
				//drawBullets(posEnemy, i);
				//Bullet(posEnemy, i);
				//draw the bullet
/*if (nextCharYmin == '/' && set != 2) {
						PointF posEnemy = enenemyvector.at(i)->Move(0, -1);
						cout << "Moving enemy down" << endl;
						enenemyvector.at(i)->Update(posEnemy);
						r = enenemyvector.at(i)->_health;
						Circle* cirle = new Circle(posEnemy, color, r, seg);
						drawList.push_back(cirle);
						drawBullets(posEnemy, i);
						Bullet(posEnemy, i);
						set = 2;
						return;
					}
					
				else {*/



























//if (nextCharYplus == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(0, 1);
//	cout << "Moving enemy up" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//}
//// move 20 y pixels rght
//if (nextCharXplus == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(1, 0);
//	cout << "Moving enemy right" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//}
////move 20 pixels down
//if (nextCharYmin == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(0, -1);
//	cout << "Moving enemy down" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//}
////move 20 pixels left
//if (nextCharXmin == '/') {
//	PointF posEnemy = enenemyvector.at(i)->Move(-1, 0);
//	cout << "Moving enemy left" << endl;
//	enenemyvector.at(i)->Update(posEnemy);
//	r = enenemyvector.at(i)->_health;
//	Circle* cirle = new Circle(posEnemy, color, r, seg);
//	drawList.push_back(cirle);
//	drawBullets(posEnemy, i);
//	Bullet(posEnemy, i);
//}
//else {
//	cout << "error" << endl;
//	return;
//}

//for (int x = 0; x < mapSizex; x++) {
//	for (int y = 0; y < mapSizey; y++) {
//		
//	}
//}
//PointF posEnemy = enenemyvector.at(i)->Move();
//cout << "Enemy id :" << endl;
//cout << enenemyvector.at(i)->_id << endl;
//cout << "Enemy health" << endl;
//cout << enenemyvector.at(i)->_health << endl;

//enenemyvector.at(i)->Update(posEnemy);
//r = enenemyvector.at(i)->_health;
//Circle* cirle = new Circle(posEnemy, color, r, seg);
//drawList.push_back(cirle);
//drawBullets(posEnemy, i);
//Bullet(posEnemy, i);
//draw the bullet





















//latter refrence use
//for (auto it = drawList.begin(); it != drawList.end(); /* nothing */) {
//	if (/* condition */) {
//		it = drawList.erase(it); // Erase returns the next iterator } else { ++it; // Increment the iterator } }
//

    //glBegin(GL_POINTS);             // Start a new drawing block for drawing points
    //    // Draw points here
    //    // The point (0,0) corresponds to the lower left corner.

    //    // The following lines will draw the point (100, 200) in red
    //    glColor3f(1.0, 0.0, 0.0);   // Set color
    //    glVertex2f(100, 200);       // Set position

    //    // The following lines will draw the point (200, 400) in blue
    //    // Alternative approach to the above:
    //    Color color = { 0.0f, 0.0f, 1.0f }; // A color (see drawtools.h)
    //    glColor3fv(color.data());           // Set color from array
    //    PointF point = { 200, 400 };        // A two dimensional point (see drawtools.h)
    //    glVertex2fv(point.data());          // Set position from array
    //glEnd(); // End of the drawing block
	

//glutTimerFunc(1500, alarm, 1);
    //glutTimerFunc(2000, alarm, 2);

    // Set the background color.
    // The color is in the (red, green, blue, alpha) format (RGBA)
    // Color values range from 0.0f to 1.0f.

	// The following funtions setup the view of the screen.
    // OpenGL actually creates a 3D world, which is displayed trough a
    // viewport (the glut window). The way pixels are projected onto
    // this viewport is setup here.




	//PointF position = { 512, 384 };
	//Color color = { 0.2f, 1, 0.2f };
	//Pixel* pixel = new Pixel{ position, color };
	//drawList.push_back(pixel);
	//pixel->draw();

	//PointF begin1 = { 30,400 };
	//PointF begin2 = { 34, 430 };
	//PointF begin3 = { 45,410 };
	//PointF begin4 = { 48, 412 };
	//float lind = 2.0;
	////Line* line = new Line{ begin1, begin2, color ,lind };
	////drawList.push_back(line);
	//float r = 10;
	//int seg = 10;
	////Circle* cirle = new Circle(begin1, color, r, seg);
	////drawList.push_back(cirle);
	//Sqaure* sq = new Sqaure(begin1, begin2,begin3,begin4, color);
	//drawList.push_back(sq);
	//float speed = 200;
	//int health = 100;
	//Enemy* en = new Enemy(begin1, speed, health );
	//PointF posEnemy = en->Move();
	//Circle* cirle = new Circle(posEnemy, color, r, seg);
	//drawList.pufloat speed2 = 0;sh_back(cirle);
	//PointF bullet = { posEnemy.x()	,posEnemy.y() };
	//Line* bulletline = new Line{ bullet, begin2, color, lind };
	//drawList.push_back(bulletline);
	//glLineStipple(110,1400);	






	////PointF position = { 512, 384 };
//Color color = { 0.2f, 1, 0.2f };
////Pixel* pixel = new Pixel{ position, color };
////drawList.push_back(pixel);
////pixel->draw();
//float speed2 = 10;
//PointF begin1 = { (30 + speed2),(20 + speed2) };
//PointF begin2 = { 34, 430 };
////PointF begin3 = { 45,410 };
////PointF begin4 = { 48, 412 };
//float lind = 2.0;
//////Line* line = new Line{ begin1, begin2, color ,lind };
//////drawList.push_back(line);
//float r = 10;
//int seg = 10;
//////Circle* cirle = new Circle(begin1, color, r, seg);
//////drawList.push_back(cirle);
//
////
////Sqaure* sq = new Sqaure(begin1, begin2, begin3, begin4, color);
////drawList.push_back(sq);
//float speed = 200;
//int health = 100;
//
////amke neew enemy and put them in the back of the enemy list
//Enemy* en = new Enemy(begin1, begin1, speed, health);
//enenemyvector.push_back(en);
//
////enemylist.push_back(en);
////enemylist._Nextnode()->_Next
//////get the front enemey
//////Enemy* enemy = enemylist.front()->Move();
//////increment the movemment of the enemy
//PointF posEnemy = enenemyvector.front()->Move();
////posEnemy = { posEnemy[0] + 50, posEnemy[1] + 50 };
////enenemyvector.at(0)->Move();
////enemylist.;
////draw the ennemy
//enenemyvector.at(0)->Update(posEnemy);
//Circle* cirle = new Circle(posEnemy, color, r, seg);
//drawList.push_back(cirle);
////PointF bullet = { posEnemy.x()	,posEnemy.y() };
//Line* bulletline = new Line{ posEnemy, begin2, color, lind };
//drawList.push_back(bulletline);
////begin1 = { posEnemy[0]	,posEnemy.y() };
////Enemy* en = new Enemy(begin1, speed, health);
////enemylist.clear();
//
////cal the display function -> draw everything 
//glutPostRedisplay();
////cal this function agains
//glutTimerFunc(160, idle, 100);